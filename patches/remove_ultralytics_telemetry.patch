--- old/ultralytics/utils/events.py	2025-06-19 00:00:00.0.0
+++ new/ultralytics/utils/events.py	2025-06-19 00:00:00.0.0
@@ -1,113 +1,8 @@
 # Ultralytics ðŸš€ AGPL-3.0 License - https://ultralytics.com/license
 
-import json
-import random
-import time
-from pathlib import Path
-from threading import Thread
-from urllib.request import Request, urlopen
-
-from ultralytics import SETTINGS, __version__
-from ultralytics.utils import ARGV, ENVIRONMENT, GIT, IS_PIP_PACKAGE, ONLINE, PYTHON_VERSION, RANK, TESTS_RUNNING
-from ultralytics.utils.downloads import GITHUB_ASSETS_NAMES
-from ultralytics.utils.torch_utils import get_cpu_info
-
-
-def _post(url: str, data: dict, timeout: float = 5.0) -> None:
-    """Send a one-shot JSON POST request."""
-    try:
-        body = json.dumps(data, separators=(",", ":")).encode()  # compact JSON
-        req = Request(url, data=body, headers={"Content-Type": "application/json"})
-        urlopen(req, timeout=timeout).close()
-    except Exception:
-        pass
-
-
 class Events:
-    """Collect and send anonymous usage analytics with rate-limiting.
-
-    Event collection and transmission are enabled when sync is enabled in settings, the current process is rank -1 or 0,
-    tests are not running, the environment is online, and the installation source is either pip or the official
-    Ultralytics GitHub repository.
-
-    Attributes:
-        url (str): Measurement Protocol endpoint for receiving anonymous events.
-        events (list[dict]): In-memory queue of event payloads awaiting transmission.
-        rate_limit (float): Minimum time in seconds between POST requests.
-        t (float): Timestamp of the last transmission in seconds since the epoch.
-        metadata (dict): Static metadata describing runtime, installation source, and environment.
-        enabled (bool): Flag indicating whether analytics collection is active.
-
-    Methods:
-        __init__: Initialize the event queue, rate limiter, and runtime metadata.
-        __call__: Queue an event and trigger a non-blocking send when the rate limit elapses.
-    """
-
-    url = "https://www.google-analytics.com/mp/collect?measurement_id=G-X8NCJYTQXM&api_secret=QLQrATrNSwGRFRLE-cbHJw"
-
-    def __init__(self) -> None:
-        """Initialize the Events instance with queue, rate limiter, and environment metadata."""
-        self.events = []  # pending events
-        self.rate_limit = 30.0  # rate limit (seconds)
-        self.t = 0.0  # last send timestamp (seconds)
-        self.metadata = {
-            "cli": Path(ARGV[0]).name == "yolo",
-            "install": "git" if GIT.is_repo else "pip" if IS_PIP_PACKAGE else "other",
-            "python": PYTHON_VERSION.rsplit(".", 1)[0],  # i.e. 3.13
-            "CPU": get_cpu_info(),
-            # "GPU": get_gpu_info(index=0) if cuda else None,
-            "version": __version__,
-            "env": ENVIRONMENT,
-            "session_id": round(random.random() * 1e15),
-            "engagement_time_msec": 1000,
-        }
-        self.enabled = (
-            SETTINGS["sync"]
-            and RANK in {-1, 0}
-            and not TESTS_RUNNING
-            and ONLINE
-            and (IS_PIP_PACKAGE or GIT.origin == "https://github.com/ultralytics/ultralytics.git")
-        )
 
     def __call__(self, cfg, device=None) -> None:
-        """Queue an event and flush the queue asynchronously when the rate limit elapses.
-
-        Args:
-            cfg (IterableSimpleNamespace): The configuration object containing mode and task information.
-            device (torch.device | str, optional): The device type (e.g., 'cpu', 'cuda').
-        """
-        if not self.enabled:
-            # Events disabled, do nothing
-            return
-
-        # Attempt to enqueue a new event
-        if len(self.events) < 25:  # Queue limited to 25 events to bound memory and traffic
-            params = {
-                **self.metadata,
-                "task": cfg.task,
-                "model": cfg.model if cfg.model in GITHUB_ASSETS_NAMES else "custom",
-                "device": str(device),
-            }
-            if cfg.mode == "export":
-                params["format"] = cfg.format
-            self.events.append({"name": cfg.mode, "params": params})
-
-        # Check rate limit and return early if under limit
-        t = time.time()
-        if (t - self.t) < self.rate_limit:
             return
 
-        # Overrate limit: send a snapshot of queued events in a background thread
-        payload_events = list(self.events)  # snapshot to avoid race with queue reset
-        Thread(
-            target=_post,
-            args=(self.url, {"client_id": SETTINGS["uuid"], "events": payload_events}),  # SHA-256 anonymized
-            daemon=True,
-        ).start()
-
-        # Reset queue and rate limit timer
-        self.events = []
-        self.t = t
-
-
 events = Events()
--- old/ultralytics/utils/__init__.py	2025-06-19 00:00:00.0.0
+++ new/ultralytics/utils/__init__.py	2025-06-19 00:00:00.0.0
@@ -462,7 +462,6 @@
 
 # Set logger
 LOGGER = set_logging(LOGGING_NAME, verbose=VERBOSE)  # define globally (used in train.py, val.py, predict.py, etc.)
-logging.getLogger("sentry_sdk").setLevel(logging.CRITICAL + 1)
 
 
 def emojis(string=""):
@@ -770,21 +769,7 @@


 def is_online() -> bool:
-    """Fast online check using DNS (v4/v6) resolution (Cloudflare + Google).
-
-    Returns:
-        (bool): True if connection is successful, False otherwise.
-    """
-    if str(os.getenv("YOLO_OFFLINE", "")).lower() == "true":
-        return False
-
-    for host in ("one.one.one.one", "dns.google"):
-        try:
-            socket.getaddrinfo(host, 0, socket.AF_UNSPEC, 0, 0, socket.AI_ADDRCONFIG)
-            return True
-        except OSError:
-            continue
-    return False
+    return True
 
 
 def is_pip_package(filepath: str = __name__) -> bool:
@@ -1111,74 +1096,6 @@
     return wrapper
 
 
-def set_sentry():
-    """Initialize the Sentry SDK for error tracking and reporting.
-
-    Only used if sentry_sdk package is installed and sync=True in settings. Run 'yolo settings' to see and update
-    settings.
-
-    Conditions required to send errors (ALL conditions must be met or no errors will be reported):
-        - sentry_sdk package is installed
-        - sync=True in YOLO settings
-        - pytest is not running
-        - running in a pip package installation
-        - running in a non-git directory
-        - running with rank -1 or 0
-        - online environment
-        - CLI used to run package (checked with 'yolo' as the name of the main CLI command)
-    """
-    if (
-        not SETTINGS["sync"]
-        or RANK not in {-1, 0}
-        or Path(ARGV[0]).name != "yolo"
-        or TESTS_RUNNING
-        or not ONLINE
-        or not IS_PIP_PACKAGE
-        or GIT.is_repo
-    ):
-        return
-    # If sentry_sdk package is not installed then return and do not use Sentry
-    try:
-        import sentry_sdk
-    except ImportError:
-        return
-
-    def before_send(event, hint):
-        """Modify the event before sending it to Sentry based on specific exception types and messages.
-
-        Args:
-            event (dict): The event dictionary containing information about the error.
-            hint (dict): A dictionary containing additional information about the error.
-
-        Returns:
-            (dict | None): The modified event or None if the event should not be sent to Sentry.
-        """
-        if "exc_info" in hint:
-            exc_type, exc_value, _ = hint["exc_info"]
-            if exc_type in {KeyboardInterrupt, FileNotFoundError} or "out of memory" in str(exc_value):
-                return None  # do not send event
-
-        event["tags"] = {
-            "sys_argv": ARGV[0],
-            "sys_argv_name": Path(ARGV[0]).name,
-            "install": "git" if GIT.is_repo else "pip" if IS_PIP_PACKAGE else "other",
-            "os": ENVIRONMENT,
-        }
-        return event
-
-    sentry_sdk.init(
-        dsn="https://888e5a0778212e1d0314c37d4b9aae5d@o4504521589325824.ingest.us.sentry.io/4504521592406016",
-        debug=False,
-        auto_enabling_integrations=False,
-        traces_sample_rate=1.0,
-        release=__version__,
-        environment="runpod" if is_runpod() else "production",
-        before_send=before_send,
-        ignore_errors=[KeyboardInterrupt, FileNotFoundError],
-    )
-    sentry_sdk.set_user({"id": SETTINGS["uuid"]})  # SHA-256 anonymized UUID hash
-
-
 class JSONDict(dict):
     """A dictionary-like class that provides JSON persistence for its contents.
 
@@ -1316,7 +1233,7 @@
             "weights_dir": str(root / "weights"),  # Model weights directory
             "runs_dir": str(root / "runs"),  # Experiment runs directory
             "uuid": hashlib.sha256(str(uuid.getnode()).encode()).hexdigest(),  # SHA-256 anonymized UUID hash
-            "sync": True,  # Enable synchronization
+            "sync": False,  # Disable synchronization
             "api_key": "",  # Ultralytics API Key
             "openai_api_key": "",  # OpenAI API Key
             "clearml": True,  # ClearML integration
@@ -1441,7 +1358,6 @@
     else platform.system()
 )
 TESTS_RUNNING = is_pytest_running() or is_github_action_running()
-set_sentry()
 
 # Apply monkey patches
 torch.save = torch_save
